# CASA00025 Group Project Title Here

## Project Summary 

Fill in the sections below to provide a brief summary of your project. Each section should have no more than 100 words. Do not edit any of the headings.

### Problem Statement 

What is the problem you’re trying to address using this application? 

### End User 

Who are you building this application for? How does it address a need this community has?

### Data

What data are you using? 

### Methodology

How are you using this data to address the problem?

### Interface

How does your application's interface work to address the needs of your end user?

## The Application 

Replace the link below with the link to your application.

:::{.column-page}

<iframe src='https://ollielballinger.users.earthengine.app/view/turkey-earthquake' width='100%' height='700px'></iframe>

:::
## How it Works 
The application's machine learning framework is organized into a modular object, GrapeML, which systematically handles environmental data processing, suitability analysis, and vineyard site prediction.

First, the computeEnvironmentalFactors function derives seven environmental variables essential for grapevine growth: Growing Season Temperature (GST), Growing Degree Days (GDD), Growing Season Precipitation (GSP), slope, aspect, elevation, and latitude. GST, GDD, and GSP are calculated from TerraClimate data filtered to the growing season (April–October). Topographic features are extracted from the SRTM digital elevation model. Latitude is derived from pixel coordinates. All data is clipped to the user-specified region and year to ensure spatial focus.

```{r}
var factors = GrapeML.computeEnvironmentalFactors(region, year);
```

Next, computeSuitabilityMask applies threshold filters to GST, GDD, GSP, slope, and elevation, generating a binary environmental suitability mask. Thresholds are based on literature but adjusted moderately to account for natural variability. The mask identifies areas that meet basic climatic and topographic requirements for grape cultivation.

```{r}
var suitabilityMask = GrapeML.computeSuitabilityMask(factors);
```

The runMachineLearning function implements the core predictive modeling. Positive samples are randomly generated within existing vineyard polygons, with the number of points scaled to existing vineyard density but capped at 200 to balance model training. To ensure data quality, positive points are only accepted if more than five points are successfully generated.

```{r}
var positivePoints = ee.FeatureCollection.randomPoints({
  region: vineyards.geometry(),
  points: positivePointCount,
  seed: 123
}).map(function(feature) {
  return feature.set('class', 1);
});
```

Negative samples are randomly created within the broader region but filtered to lie within areas classified as unsuitable by the inverted suitability mask. Similarly, a minimum number of negative points must be met to proceed.

```{r}
var negativePoints = ee.FeatureCollection.randomPoints({
  region: region,
  points: 400,
  seed: 456
}).filter(ee.Filter.bounds(nonSuitableArea.selfMask().geometry()))
  .map(function(feature) {
    return feature.set('class', 0);
  });
```

A feature image is constructed by stacking the seven variables into a single multiband image. Environmental values are sampled at the positive and negative points to create a labeled dataset.

```{r}
var featureImage = ee.Image.cat([
  factors.gst.rename('GST'),
  factors.gdd.rename('GDD'),
  factors.gsp.rename('GSP'),
  factors.slope.rename('slope'),
  factors.aspect.rename('aspect'),
  factors.elevation.rename('elevation'),
  factors.latitude.rename('latitude')
]).clip(region);

var sampledPoints = featureImage.sampleRegions({
  collection: allPoints,
  properties: ['class'],
  scale: 100,
  tileScale: 16
});
```

Samples are split into 70% training and 30% testing subsets to ensure balanced evaluation.

```{r}
sampledPoints = sampledPoints.randomColumn();
var training = sampledPoints.filter(ee.Filter.lt('random', 0.7));
var testing = sampledPoints.filter(ee.Filter.gte('random', 0.7));
```

The classification model is a Random Forest consisting of 50 decision trees, with two variables randomly selected at each split to reduce overfitting. Training is performed on the sampled feature set, using "class" (0 or 1) as the label.

```{r}
var classifier = ee.Classifier.smileRandomForest({
  numberOfTrees: 50,
  variablesPerSplit: 2,
  seed: 42
}).train({
  features: training,
  classProperty: 'class',
  inputProperties: features
});
```

Model evaluation is conducted on the testing set. An error matrix is computed to assess classification performance, and overall accuracy is reported. Feature importance scores are extracted to interpret which environmental variables most strongly influence suitability predictions.

Final predictions are made across the entire region. The trained classifier outputs a probability surface, where each pixel value represents the likelihood of being suitable for vineyard development.

```{r}
var probabilityClassifier = classifier.setOutputMode('PROBABILITY');
var suitabilityScore = featureImage.classify(probabilityClassifier)
    .select('classification')
    .reproject({crs: 'EPSG:4326', scale: 250});
```

Pixels with a probability greater than 0.7 are designated as high-suitability areas. The total area of these zones is calculated. If data availability is insufficient, the basic environmental suitability mask is used instead.

The modular design ensures flexibility, robustness, and scalability, enabling users to apply the workflow to different regions and years as climatic conditions evolve.